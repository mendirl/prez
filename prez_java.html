<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projet Amber — Présentation</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .remark-slide-content { font-size: 28px; }
    code { font-size: 0.9em; }
    pre code { font-size: 0.8em; line-height: 1.3; }
  </style>
</head>
<body>
<textarea id="source" style="display:none;">
class: center, middle

# Résumé du Projet Amber (Java)

Intérêt: cadrer l’objectif du projet et pourquoi il accélère l’évolution du langage.

Le Projet Amber est une initiative de l’OpenJDK visant à accélérer l’évolution du langage Java avec des fonctionnalités concises et expressives.

---

## Périmètre

Intérêt: clarifier ce qui relève d’Amber (syntaxe, modélisation) vs. autres projets (Loom, Panama).

Important: Project Amber ne couvre pas la concurrence bas niveau (Loom) ni l’interopérabilité native (Panama). Il se concentre sur la syntaxe et la modélisation des données.

---

## Principales fonctionnalités

Intérêt: vision d’ensemble des nouveautés majeures pour naviguer dans la suite des pages.

- var (inférence de type locale) — JEP 286 (Java 10)
- Text Blocks — JEP 355/378 (Java 15)
- Switch Expressions — JEP 325/354/361 (Java 14)
- Pattern Matching pour `instanceof` — JEP 305/375/394 (Java 16)
- Records — JEP 359/384/395 (Java 16)
- Sealed Classes — JEP 360/397/409 (Java 17)
- Pattern Matching pour `switch` — JEP 406/420/433/441 (Java 21)
- Record Patterns — JEP 405/432/440 (Java 21)
- String Templates — JEP 430/459/465 (preview)
- Unnamed Patterns/Variables — JEP 443/456 (preview)

---

## Exemples: var, text blocks

Intérêt: écrire moins de code répétitif (var) et manipuler des chaînes multi‑lignes propres (text blocks).

JEPs (par version): Java 10 — 286 (var); Java 15 — 355/378 (Text Blocks)

```java
var list = List.of("a", "b");

String json = """
{
  "name": "Amber",
  "active": true
}
""";
```

---

## Switch expressions

Intérêt: rendre les branches exhaustives, exprimer des valeurs et réduire le boilerplate des instructions conditionnelles.

JEPs (par version): Java 12 — 325; Java 13 — 354; Java 14 — 361

```java
int days = switch (month) {
  case JAN, MAR, MAY -> 31;
  case APR -> 30;
  default -> 28;
};
```

---

## Pattern matching, records, sealed

Intérêt: mieux modéliser le domaine (records), contrôler l’héritage (sealed) et simplifier le dispatch (pattern matching).

JEPs (par version):
- Records: Java 14 — 359; Java 15 — 384; Java 16 — 395
- Sealed Classes: Java 15 — 360; Java 16 — 397; Java 17 — 409

```java
sealed interface Shape permits Circle, Rectangle {}
record Circle(double r) implements Shape {}
record Rectangle(double w, double h) implements Shape {}

static double area(Shape s) {
  return switch (s) {
    case Circle c -> Math.PI * c.r() * c.r();
    case Rectangle(var w, var h) -> w * h;
  };
}
```

---

## Pattern matching pour instanceof et switch

Intérêt: écrire des tests de type et des choix de contrôle plus sûrs et plus concis, en évitant les casts et les erreurs.

JEPs (par version):
- instanceof: Java 10 — 305; Java 14 — 375; Java 16 — 394
- switch: Java 17 — 406; Java 18 — 420; Java 19 — 433; Java 21 — 441

```java
if (o instanceof String s) {
  System.out.println(s.length());
}

String d = switch (o) {
  case Integer i -> "int=" + i;
  case String s -> s;
  default -> "?";
};
```

---

## Record patterns

Intérêt: déstructurer des enregistrements directement dans les conditions pour extraire les champs de façon sûre.

JEPs (par version): Java 19 — 405; Java 20 — 432; Java 21 — 440

```java
if (p instanceof Point(int x, int y)) {
  // ...
}
```

---

## String templates (preview)

Intérêt: interpoler des valeurs dans des chaînes de manière lisible et potentiellement plus sûre (moteurs de templates).

JEPs (par version): Java 21 — 430; Java 22 — 459; Java 23 — 465 (preview)

```java
String msg = STR."Hello, \{user.name()}!";
```

---

## Bénéfices clés

Intérêt: synthèse finale des gains de productivité, de sûreté et de lisibilité apportés par Amber.

- Moins de verbosité
- Modélisation de données claire (records, sealed)
- Logique de contrôle sûre et expressive (switch, patterns)
- Chaînes multi‑lignes lisibles (text blocks)

---

## Références

Intérêt: accéder rapidement aux ressources officielles, spécifications et état des JEPs.

- OpenJDK Project Amber: https://openjdk.org/projects/amber/
- Design notes (JEPs): https://openjdk.org/projects/amber/design-notes
- JDK JEP Index: https://openjdk.org/jeps/0

---

## Projet Valhalla — aperçu

Intérêt: comprendre l’objectif de Valhalla (performances et modélisation) et son lien avec l’écosystème Java.

Le Projet Valhalla vise à introduire des types valeur et des classes primitives (sans identité), ainsi que la spécialisation des génériques, afin de réduire l’overhead d’allocation/indirection et d’améliorer la locality des données.

---

## Concepts clés (Valhalla)

Intérêt: poser les notions pour lire les exemples et les JEPs.

- Value objects (objets sans identité) et classes primitives: pas d’égalité par identité, potentiellement flattenés en mémoire.
- Nullabilité contrôlée: types valeur non-null par défaut, variantes nullable possibles selon les propositions.
- Flattening/inline: disposer les champs en ligne pour éviter les pointeurs (meilleure locality/cache).
- Génériques spécialisés: List<int> sans boxing, évite Integer et l’auto-boxing.

---

## JEPs (Valhalla) — repères par version

Intérêt: situer l’avancement dans les JDK récents (évolutif, à vérifier régulièrement).

- Java 22–23: prototypes/EA autour des classes primitives et valeur (préviews successives).
- JEP 401 (Primitive types in patterns, hypothétique), JEP 402/404 (spécialisations génériques, exploratoires) — à confirmer selon l’index JEP.
- Suivre: https://openjdk.org/projects/valhalla/ et https://openjdk.org/jeps/0 (mots‑clés: Valhalla, primitive classes, value objects, specialized generics).

Note: La numérotation exacte des JEP Valhalla évolue; privilégier l’index JEP pour l’état courant.

---

## Exemples (hypothétiques / preview)

Intérêt: illustrer l’ambition (syntaxe indicative; peut différer des builds EA).

```java
// Déclaration d’une classe primitive (valeur) — syntaxe sujette à changement
primitive class Complex {
  double re;
  double im;
  double abs() { return Math.hypot(re, im); }
}

// Utilisation sans boxing et avec flattening potentiel
var nums = Vector.ofInt(1, 2, 3); // Ex.: collections/génériques spécialisés
```

---

## Où s’insère Valhalla vs Amber ?

Intérêt: distinguer objectifs.

- Amber: expressivité et concision de la syntaxe (records, patterns, switch, templates).
- Valhalla: modèle de types et représentation mémoire (types valeur, classes primitives, génériques spécialisés) pour des gains de performance.

---

## Références

Intérêt: accéder rapidement aux ressources officielles, spécifications et état des JEPs.

- OpenJDK Project Amber: https://openjdk.org/projects/amber/
- OpenJDK Project Valhalla: https://openjdk.org/projects/valhalla/
- OpenJDK Project Leyden: https://openjdk.org/projects/leyden/
- Design notes (Amber): https://openjdk.org/projects/amber/design-notes
- JDK JEP Index: https://openjdk.org/jeps/0

---

## Projet Leyden — aperçu

Intérêt: réduire le temps de démarrage, l’empreinte mémoire et améliorer la prévisibilité via build-time/static images.

Le Projet Leyden vise à apporter des mécanismes d’optimisation en amont (build‑time) et des images statiques pour Java, afin d’améliorer le démarrage, réduire le RSS, et stabiliser les performances dans les environnements cloud/serverless.

---

## Concepts clés (Leyden)

Intérêt: poser les notions pour comprendre l’approche et ses compromis.

- AOT/Build-time initialisation: déplacer du travail du runtime vers le build.
- Images statiques natives: générer un binaire autonome (sans JIT) pour démarrage ultra‑rapide.
- Fermeture du monde (closed-world assumptions): contraintes pour l’analyse statique (réflexion, proxies).
- Profil « cloud-friendly »: empreinte mémoire réduite, démarrage prévisible, cold starts améliorés.

---

## JEPs (Leyden) — repères par version

Intérêt: repérer les jalons dans les JDK récents; vérifiez l’index JEP pour l’état exact.

- Java 21–23: travaux autour de l’AOT, CDS, et images statiques expérimentales.
- JEP 447 (Preview) — Créer des images statiques de programmes Java (exemple de jalon lié; à vérifier selon l’index).
- Suivre: https://openjdk.org/projects/leyden/ et https://openjdk.org/jeps/0 (mots‑clés: Leyden, static images, AOT, CDS).

Note: la numérotation exacte et l’état des JEP Leyden évoluent; privilégier l’index JEP.

---

## Exemple (indicatif)

Intérêt: illustrer la création d’une image statique (syntaxe et outils susceptibles d’évoluer).

```bash
# Exemple indicatif; reportez-vous à la JEP et à la doc d’outils pour la syntaxe exacte
# Compilation
javac -d out src/main/java/com/example/App.java
# Génération d’une image statique (commande sujette à changement selon JEP/outils)
javac -static-image -cp out com.example.App -o app
```

---

## Où s’insère Leyden vs Amber/Valhalla ?

Intérêt: positionner Leyden par rapport aux autres projets OpenJDK.

- Amber: expressivité du langage et modélisation.
- Valhalla: modèle de types et représentation mémoire pour perfs.
- Leyden: packaging/optimisation build‑time et images statiques pour démarrage/empreinte.

---

## Projet Loom — aperçu

Intérêt: simplifier la concurrence en offrant des threads légers (virtual threads) à coût réduit, sans changer le modèle de programmation.

Le Projet Loom apporte des virtual threads, la concurrence structurée et les scoped values, afin de rendre les applications concurrentes plus simples, plus lisibles et plus scalables, sans réécrire en mode async explicite.

---

## Concepts clés (Loom)

Intérêt: poser les notions pour comprendre comment Loom change l’écriture de code concurrent.

- Virtual Threads (threads légers gérés par la JVM, M:N sur OS threads).
- Structured Concurrency (gérer un groupe de tâches comme une unité, avec scopes et lifecycles).
- Scoped Values (successeurs thread-safe aux ThreadLocals pour passer des contextes immuables).
- Continuations (infrastructure sous-jacente permettant la suspension/reprise des virtual threads).

---

## JEPs (Loom) — repères par version

Intérêt: repérer les jalons majeurs et leur état; vérifiez l’index JEP pour l’état exact.

- Java 19 — 425 (Virtual Threads, preview); 428 (Structured Concurrency, incubator); 429 (Scoped Values, incubator)
- Java 20 — 436 (Virtual Threads, 2e preview); 437 (Structured Concurrency, 2e incubator); 429 (Scoped Values, incubator)
- Java 21 — 444 (Virtual Threads, final); 453 (Structured Concurrency, preview); 446 (Scoped Values, preview)
- Java 22 — 462 (Structured Concurrency, 2e preview); 464 (Scoped Values, 2e preview)
- Java 23 — 476 (Scoped Values, 3e preview) — à confirmer via https://openjdk.org/jeps/0

Note: toujours vérifier l’index JEP pour les derniers états (final/preview/incubator).

---

## Exemple: Virtual Threads

Intérêt: paralléliser massivement des tâches bloquantes avec une syntaxe familière.

```java
try (var executor = java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
  List<Callable<String>> tasks = urls.stream()
      .map(url -> (Callable<String>) () -> httpClient.get(url))
      .toList();
  var results = executor.invokeAll(tasks);
}

// Ou créer un virtual thread directement
Thread.startVirtualThread(() -> doBlockingWork());
```

---

## Exemple: Structured Concurrency / Scoped Values (indicatif)

Intérêt: gérer un groupe de sous-tâches comme une unité et propager un contexte immuable.

```java
import java.util.concurrent.StructuredTaskScope;

static final jdk.incubator.concurrent.ScopedValue<String> USER = jdk.incubator.concurrent.ScopedValue.newInstance();

String fetchProfile(String userId) throws InterruptedException {
  return jdk.incubator.concurrent.ScopedValue.where(USER, userId)
      .call(() -> {
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
          var user   = scope.fork(() -> loadUser(USER.get()));
          var orders = scope.fork(() -> loadOrders(USER.get()));
          scope.join();
          scope.throwIfFailed();
          return format(user.resultNow(), orders.resultNow());
        }
      });
}
```

---

## Où s’insère Loom vs Amber/Valhalla/Leyden ?

Intérêt: positionner Loom par rapport aux autres projets OpenJDK.

- Amber: expressivité du langage et modélisation.
- Valhalla: modèle de types et représentation mémoire pour perfs.
- Leyden: packaging/optimisation build‑time et images statiques.
- Loom: concurrence simplifiée via virtual threads, structured concurrency et scoped values.

---

## Références (Loom)

Intérêt: accéder rapidement aux ressources officielles.

- OpenJDK Project Loom: https://openjdk.org/projects/loom/
- JDK JEP Index: https://openjdk.org/jeps/0

---

## Projet Lilliput — aperçu

Intérêt: augmenter la densité mémoire et réduire l’empreinte en réduisant la taille des en-têtes d’objets de la JVM.

Le Projet Lilliput vise à compacter les object headers (ex.: passer de 128/96 bits vers 64 bits sur certaines plateformes), tout en préservant les fonctionnalités (verrouillage, hashCode, marquage GC), afin d’améliorer la densité du heap et potentiellement la performance des applications à forte allocation.

---

## Concepts clés (Lilliput)

Intérêt: comprendre ce qui compose l’entête d’objet et les compromis.

- Object header: mark word (verrouillage, identité/hash), pointeur de classe (Klass pointer), éventuels bits GC.
- Compression/encodage: empaqueter les métadonnées dans moins de bits (pointer compression, marquage compact).
- Impact GC et verrous: compatibilité avec divers collecteurs (G1, Shenandoah, ZGC) et modes de locking/biased locking (selon l’état du projet).
- Alignement et taille minimale d’objet: ajustements pour conserver l’alignement mémoire tout en réduisant l’overhead.

---

## Repères (Lilliput) — à suivre par version

Intérêt: pointer vers les jalons sans figer des numéros susceptibles d’évoluer.

- Java 21–23+: travaux continus dans des branches/prototypes Lilliput (selon builds JVM).
- Suivre: https://openjdk.org/projects/lilliput/ et l’index JEP: https://openjdk.org/jeps/0 (mots‑clés: Lilliput, object header, mark word).
- Note: l’intégration/état exact dépend des JEP et des portages par collecteur; vérifiez régulièrement l’index JEP.

---

## Impacts et cas d’usage

Intérêt: relier la réduction d’entête à des bénéfices concrets.

- Densité mémoire accrue: plus d’objets par cache line/page → meilleure locality potentielle.
- Réduction du RSS/heap pour applis orientées objets et micro-objets.
- Gains indirects possibles sur le GC et la bande passante mémoire.
- Pertinence en environnements cloud/containers à ressources contraintes.

---

## Où s’insère Lilliput vs Amber/Valhalla/Leyden/Loom ?

Intérêt: positionner Lilliput parmi les autres projets.

- Amber: expressivité et concision du langage.
- Valhalla: modèle de types et représentation (types valeur, génériques spécialisés).
- Leyden: optimisation build‑time et images statiques pour démarrage/empreinte.
- Loom: concurrence simplifiée (virtual threads, structured concurrency).
- Lilliput: efficacité mémoire au niveau de la VM via entêtes d’objets plus compacts.

---

## Références (Lilliput)

Intérêt: accéder rapidement aux ressources officielles.

- OpenJDK Project Lilliput: https://openjdk.org/projects/lilliput/
- JDK JEP Index: https://openjdk.org/jeps/0

---

## Remarques

Intérêt: rappeler de vérifier l’état le plus récent (release/preview/deprecated) selon la version de JDK.

Vérifiez la JEP correspondante pour l’état le plus à jour (JDK 21–23+), et, pour Valhalla, Leyden, Loom et Lilliput, fiez‑vous aux builds EA, aux toolchains et aux JEPs en cours d’élaboration.
</textarea>

<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>
  var slideshow = remark.create({
    ratio: '16:9',
    highlightStyle: 'github',
    highlightLines: true,
    navigation: {
      scroll: false,
      touch: true
    }
  });
</script>
</body>
</html>
